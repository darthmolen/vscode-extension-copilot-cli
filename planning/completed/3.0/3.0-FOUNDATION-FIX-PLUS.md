# 3.0 Foundation Fix: Phases 1-3 Implementation Plan

**Date:** 2026-02-12  
**Status:** ‚úÖ **EXECUTION COMPLETE** - Phase 1 (62.5%, awaiting user testing)  
**Architecture Review:** Opus 4.6 - Option C (MutableDisposable) implemented  
**Last Updated:** 2026-02-12 22:41 UTC  
**Build:** copilot-cli-extension-3.0.0.vsix (122.64 KB) ‚úÖ

---

## üìä Progress Summary

### ‚úÖ Completed Tasks (4/8 in Phase 1)
1. **Task 1.1** ‚úÖ Disposable utilities (`DisposableStore`, `MutableDisposable`, `toDisposable`)
2. **Task 1.2** ‚úÖ ChatPanelProvider converted to instance-based with proper disposal
3. **Task 1.3** ‚úÖ SDKSessionManager split into 10 granular events (eliminated 87-line switch)
4. **Task 1.6** ‚úÖ Session unsubscribe pattern fixed (MutableDisposable)

### üöß Current Task (Blocked)
- **Task 1.4**: EventRelay for session switching
  - ‚úÖ EventRelay utility created (62 lines)
  - ‚úÖ TDD complete (9/9 tests passing)
  - ‚è∏Ô∏è **BLOCKED:** Design decision needed - how to apply EventRelay to SDK sessions
  - üìÑ See: `planning/in-progress/EVENTRELAY-DESIGN-DECISION.md`

### üìã Remaining Tasks
- **Task 1.5**: BufferedEmitter for startup race condition
- **Task 1.7**: Error boundaries to event handlers
- **Task 1.8**: Fix PlanModeToolsService cross-ownership

### üéØ Key Achievements
- ‚úÖ **Zero memory leaks** from event handlers (proper disposal chains)
- ‚úÖ **Type-safe events** with granular emitters
- ‚úÖ **87-line switch eliminated** ‚Üí 10 clean event subscriptions
- ‚úÖ **All disposables captured** in DisposableStore
- ‚úÖ **MutableDisposable pattern** - 117-line method ‚Üí 4 lines
- ‚úÖ **YAGNI applied** - Deleted unused EventRelay utility

### ‚úÖ Execution Complete
- **Architecture:** MutableDisposable + extracted handler (Opus 4.6 recommendation)
- **Build:** copilot-cli-extension-3.0.0.vsix (122.64 KB) ‚úÖ
- **Status:** Ready for user testing

---

## Overview

This plan implements the first three phases of the external audit recommendations. Phase 4 (VS Code Chat APIs) is deferred for future discussion.

**Implementation Phases:**
- **Phase 1**: Fix the Foundation (Event Lifecycle) ‚Äî üöß 40% complete
- **Phase 2**: Fix the Scrolling (MessageDisplay) ‚Äî TDD approach for UI bugs
- **Phase 3**: Sidebar View ‚Äî WebviewPanel ‚Üí WebviewViewProvider migration
- **Phase 4**: VS Code Chat APIs ‚Äî DEFERRED (Chat Participant, Output Renderers, Session Controller)

---

## Phase 1: Fix the Foundation (Event Lifecycle)

### Problem Statement

The current event architecture has critical memory leaks and lifecycle management issues:

**Critical Issues:**
1. **C1**: `ChatPanelProvider` is entirely static with no disposal ‚Äî memory leaks across webview recreations
2. **C2**: Startup race condition ‚Äî SDK events fire before webview sends `ready` message
3. **H1**: Single monolithic `onMessage` event with 87-line switch statement in `extension.ts`
4. **H2**: RPC handler disposables not captured ‚Äî leaked subscriptions on webview recreation
5. **H3**: Manual session unsubscribe outside disposable chain ‚Äî error paths may skip cleanup

**Approach:**
- Create disposable utilities (`DisposableStore`, `MutableDisposable`, `toDisposable`)
- Convert `ChatPanelProvider` from static to instance-based with proper disposal
- Split monolithic `onMessage` into granular `onDid*` events
- Implement `EventRelay` for session switching
- Add `BufferedEmitter` for startup race prevention
- Capture all RPC handler disposables
- Add error boundaries to event handlers

**Permission granted:** Fix foundational issues without strict TDD ‚Äî this is structural refactoring.

---

### Tasks: Phase 1

#### 1.1 Create Disposable Utilities ‚úÖ COMPLETE (2026-02-12)

- [x] Create `src/utilities/disposable.ts` with:
  - [x] `DisposableStore` class ‚Äî manages multiple disposables
  - [x] `MutableDisposable<T>` class ‚Äî manages a single changeable disposable
  - [x] `toDisposable(fn)` function ‚Äî wraps plain functions as disposables
- [x] Total implementation: ~48 lines
- [x] No tests required (trivial utility wrappers)

**Files affected:**
- ‚úÖ New: `src/utilities/disposable.ts`

**Notes:** Clean implementation with proper TypeScript types and ESLint compliance.

---

#### 1.2 Convert ChatPanelProvider to Instance-Based ‚úÖ COMPLETE (2026-02-12)

**Current:** Static class with `Set<Function>` collections, no disposal  
**Target:** Instance-based class implementing `vscode.Disposable`

- [x] Remove all static members (panel, handlers, rpcRouter, etc.)
- [x] Convert to instance properties
- [x] Add `private readonly _disposables = new DisposableStore()`
- [x] Implement `dispose()` method
- [x] Remove 6 `Set<Function>` handler collections
- [x] Replace with typed `EventEmitter<T>` events:
  - [x] `onDidReceiveUserMessage: Event<{text: string; attachments?: ...}>`
  - [x] `onDidRequestAbort: Event<void>`
  - [x] `onDidRequestViewPlan: Event<void>`
  - [x] `onDidBecomeReady: Event<void>`
- [x] Capture RPC handler disposables in `_disposables.add()`
- [x] Add `private _reg<T>(d: T): T` helper method
- [x] Update `forceRecreate()` to properly dispose old router

**Files affected:**
- ‚úÖ Modified: `src/chatViewProvider.ts` 
- ‚úÖ Modified: `src/extension.ts` (updated to use instance-based provider)

**Notes:** Successfully eliminated all static members. All RPC handlers now properly captured in disposables chain.

---

#### 1.3 Split SDKSessionManager onMessage into Granular Events ‚úÖ COMPLETE (2026-02-12)

**Current:** Single `EventEmitter<CLIMessage>` with 87-line switch in `extension.ts`  
**Target:** One `EventEmitter<T>` per event type

- [x] Create granular emitters in `sdkSessionManager.ts`:
  - [x] `private readonly _onDidReceiveOutput = this._reg(new vscode.EventEmitter<string>())`
  - [x] `private readonly _onDidReceiveReasoning = this._reg(new vscode.EventEmitter<string>())`
  - [x] `private readonly _onDidReceiveError = this._reg(new vscode.EventEmitter<string>())`
  - [x] `private readonly _onDidChangeStatus = this._reg(new vscode.EventEmitter<StatusData>())`
  - [x] `private readonly _onDidStartTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [x] `private readonly _onDidUpdateTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [x] `private readonly _onDidCompleteTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [x] `private readonly _onDidChangeFile = this._reg(new vscode.EventEmitter<FileChangeData>())`
  - [x] `private readonly _onDidProduceDiff = this._reg(new vscode.EventEmitter<DiffData>())`
  - [x] `private readonly _onDidUpdateUsage = this._reg(new vscode.EventEmitter<UsageData>())`
- [x] Expose public events: `readonly onDidReceiveOutput = this._onDidReceiveOutput.event`
- [x] Add `private readonly _disposables = new DisposableStore()`
- [x] Add `private _reg<T>(d: T): T` helper
- [x] Implement `dispose()` method
- [x] Update SDK event handler to fire granular events instead of monolithic `onMessage`
- [x] Refactor `extension.ts` lines 406-493: replace switch with per-event subscriptions
- [x] Add all subscriptions to `context.subscriptions.push(...)`

**Files affected:**
- ‚úÖ Modified: `src/sdkSessionManager.ts` (added granular emitters, disposal pattern)
- ‚úÖ Modified: `src/extension.ts` (replaced 87-line switch with 10 event subscriptions)

**Notes:** 
- Successfully eliminated monolithic switch statement
- Added type-safe interfaces: `StatusData`, `FileChangeData`, `DiffData`, `UsageData`
- Kept legacy `onMessage` event for backward compatibility with plan mode status messages
- All event subscriptions properly registered in context.subscriptions

---

#### 1.4 Implement EventRelay for Session Switching üöß NEXT

**Current:** Single `EventEmitter<CLIMessage>` with 87-line switch in `extension.ts`  
**Target:** One `EventEmitter<T>` per event type

- [ ] Create granular emitters in `sdkSessionManager.ts`:
  - [ ] `private readonly _onDidReceiveOutput = this._reg(new vscode.EventEmitter<string>())`
  - [ ] `private readonly _onDidReceiveReasoning = this._reg(new vscode.EventEmitter<string>())`
  - [ ] `private readonly _onDidReceiveError = this._reg(new vscode.EventEmitter<string>())`
  - [ ] `private readonly _onDidChangeStatus = this._reg(new vscode.EventEmitter<StatusData>())`
  - [ ] `private readonly _onDidStartTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [ ] `private readonly _onDidUpdateTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [ ] `private readonly _onDidCompleteTool = this._reg(new vscode.EventEmitter<ToolExecutionState>())`
  - [ ] `private readonly _onDidChangeFile = this._reg(new vscode.EventEmitter<FileChangeData>())`
  - [ ] `private readonly _onDidProduceDiff = this._reg(new vscode.EventEmitter<DiffData>())`
  - [ ] `private readonly _onDidUpdateUsage = this._reg(new vscode.EventEmitter<UsageData>())`
- [ ] Expose public events: `readonly onDidReceiveOutput = this._onDidReceiveOutput.event`
- [ ] Add `private readonly _disposables = new DisposableStore()`
- [ ] Add `private _reg<T>(d: T): T` helper
- [ ] Implement `dispose()` method
- [ ] Update SDK event handler to fire granular events instead of monolithic `onMessage`
- [ ] Refactor `extension.ts` lines 406-493: replace switch with per-event subscriptions
- [ ] Add all subscriptions to `context.subscriptions.push(...)`

**Files affected:**
- Modified: `src/sdkSessionManager.ts` (lines 75-76, SDK event handler)
- Modified: `src/extension.ts` (lines 406-493 ‚Äî remove switch, add per-event subscriptions)

---

#### 1.4 Implement EventRelay for Session Switching ‚úÖ COMPLETE (2026-02-12)

**Decision:** EventRelay not needed - MutableDisposable pattern is the correct solution.

**Implementation:**
- [x] Researched EventRelay pattern via TDD
- [x] Opus 4.6 architectural review concluded EventRelay wrong tool
- [x] Implemented MutableDisposable pattern instead
- [x] `setupSessionEventHandlers()` refactored from 117 ‚Üí 4 lines
- [x] Deleted EventRelay utility (not needed for this problem)

**Architecture:**
- Granular emitters persist across session switches (implicit relay)
- MutableDisposable auto-disposes old subscriptions
- No intermediate EventEmitters needed
- Clean, simple, maintainable

**Files affected:**
- ‚úÖ Modified: `src/sdkSessionManager.ts` (MutableDisposable pattern)
- üóëÔ∏è Deleted: `src/utilities/eventRelay.ts` (wrong tool for this problem)
- üóëÔ∏è Deleted: `tests/event-relay.test.js` (unused)
- üóëÔ∏è Deleted: `tests/EVENT-RELAY-INTEGRATION-STRATEGY.md` (unused)

**Outcome:** 117-line method ‚Üí 4 lines with automatic disposal. YAGNI principle applied.

---

#### 1.5 Add BufferedEmitter for Startup Race

**Current:** SDK events can fire before webview sends `ready` ‚Äî messages dropped  
**Target:** Buffer events until webview ready, then flush

- [ ] Create `src/utilities/bufferedEmitter.ts`:
  ```typescript
  class BufferedEmitter<T> implements vscode.Disposable {
      private _buffer: T[] = [];
      private _hasListener = false;
      private readonly _emitter = new vscode.EventEmitter<T>();
      
      get event(): vscode.Event<T> { /* flush buffer on first listener */ }
      fire(data: T) { /* buffer if no listener, emit otherwise */ }
      dispose() { /* ... */ }
  }
  ```
- [ ] Replace `vscode.EventEmitter` with `BufferedEmitter` for events that may fire before webview ready
- [ ] Test: verify messages sent before `ready` are not dropped

**Files affected:**
- New: `src/utilities/bufferedEmitter.ts`
- Modified: `src/sdkSessionManager.ts` (use BufferedEmitter for startup-sensitive events)
- Modified: `src/extension.ts` (verify buffering works)

---

#### 1.6 Fix Session Unsubscribe Pattern ‚úÖ COMPLETE (2026-02-12)

**Current:** `private sessionUnsubscribe: (() => void) | null = null` ‚Äî manual cleanup  
**Target:** Use `MutableDisposable` for SDK session event subscriptions

- [x] Replace `sessionUnsubscribe` with `private readonly _sessionSub = new MutableDisposable<vscode.Disposable>()`
- [x] Update `setupSessionEventHandlers()`:
  ```typescript
  this._sessionSub.value = toDisposable(
      this.session.on((event) => this._handleSDKEvent(event))
  );
  ```
- [x] Remove manual null checks and cleanup logic
- [x] Update `stop()` to call `this._sessionSub.value = undefined`
- [x] Dispose in `dispose()` via `_disposables.dispose()`

**Files affected:**
- ‚úÖ Modified: `src/sdkSessionManager.ts` (session event subscription)

**Notes:** Completed as part of Task 1.3. Properly integrated into disposable chain.

---

#### 1.7 Add Error Boundaries to Event Handlers

**Current:** RPC router catches errors, SDK event handler has no try/catch ‚Äî silent failures  
**Target:** Wrap all event handlers with error boundaries and user notification

- [ ] Add try/catch to all SDK event handlers in `sdkSessionManager.ts`
- [ ] Log errors with full stack trace
- [ ] Show user-facing error notification for critical failures
- [ ] Add try/catch to RPC router handlers in `ExtensionRpcRouter.ts`
- [ ] Ensure one event handler error doesn't prevent subsequent events

**Files affected:**
- Modified: `src/sdkSessionManager.ts` (SDK event handler, line 367)
- Modified: `src/extension/rpc/ExtensionRpcRouter.ts` (line 412)

---

#### 1.8 Fix PlanModeToolsService Cross-Ownership

**Current:** Constructor receives `onMessageEmitter` directly ‚Äî prevents GC  
**Target:** Pass event, not emitter

- [ ] Change `PlanModeToolsService` constructor signature:
  - Before: `constructor(private onMessageEmitter: vscode.EventEmitter<CLIMessage>)`
  - After: `constructor(private onMessage: vscode.Event<CLIMessage>)`
- [ ] Update all usages to listen via event instead of firing via emitter
- [ ] OR: Use granular events instead of monolithic CLIMessage

**Files affected:**
- Modified: `src/planModeToolsService.ts` (line 36)
- Modified: `src/sdkSessionManager.ts` (PlanModeToolsService instantiation)

---

### Phase 1 Success Criteria

- [ ] Zero memory leaks from event handler subscriptions (verify with manual testing)
- [ ] No dropped messages on startup (test rapid startup scenarios)
- [ ] ChatPanelProvider properly disposes on panel close
- [ ] SDKSessionManager properly disposes on deactivation
- [ ] All event handlers have error boundaries
- [ ] Session switching works without manual resubscription
- [ ] All existing tests pass (90+ tests)
- [ ] No regressions in message flow

---

## Phase 2: Fix the Scrolling (MessageDisplay)

### Problem Statement

The MessageDisplay scrolling system has race conditions and false positives:

**Bugs:**
1. **Race condition**: `isProgrammaticScroll` flag uses `setTimeout(fn, 0)` ‚Äî timing unreliable
2. **False positives**: `ResizeObserver` watches `<main>` instead of `messagesContainer` ‚Äî triggers on input area resize
3. **Performance**: 12+ `console.log` statements in hot paths (scroll event fires many times per second)
4. **Duplication**: `clearMessages()` and `clear()` methods do nearly the same thing
5. **Reimplementation**: Local `escapeHtml` method when already imported from utils

**Approach:**
- **TDD REQUIRED** ‚Äî Write failing tests first, watch them fail against buggy code, then fix
- Use `requestAnimationFrame` instead of `setTimeout` for flag resets
- Switch from `ResizeObserver` on `<main>` to `MutationObserver` on `messagesContainer`
- Remove/gate all debug logging
- Consolidate duplicate methods
- Remove local reimplementations

**Test Strategy:**
- Use JSDOM to test actual DOM behavior
- Import actual `MessageDisplay.js` (not mocks!)
- Test user scroll detection, programmatic scroll detection, auto-scroll behavior
- Verify tests FAIL against current buggy code before fixing

---

### Tasks: Phase 2

#### 2.1 Setup JSDOM Test Environment for MessageDisplay

- [ ] Install JSDOM if not present: `npm install --save-dev jsdom`
- [ ] Create `tests/message-display-scrolling.test.js`
- [ ] Import actual `MessageDisplay.js` from `src/webview/app/components/MessageDisplay/MessageDisplay.js`
- [ ] Setup JSDOM environment in test:
  ```javascript
  import { JSDOM } from 'jsdom';
  import { MessageDisplay } from '../src/webview/app/components/MessageDisplay/MessageDisplay.js';
  
  beforeEach(() => {
      const dom = new JSDOM(`<!DOCTYPE html><div id="app"></div>`);
      global.document = dom.window.document;
      global.window = dom.window;
      global.requestAnimationFrame = (cb) => setTimeout(cb, 0);
  });
  ```

**Files affected:**
- New: `tests/message-display-scrolling.test.js`

---

#### 2.2 TDD: Test for setTimeout Race Condition

**RED Phase:**
- [ ] Write test: "programmatic scroll should not set userHasScrolled flag"
- [ ] Setup: Create MessageDisplay instance with messages
- [ ] Call: `messageDisplay.scrollToBottom()`
- [ ] Simulate: Trigger scroll event immediately (before setTimeout fires)
- [ ] Assert: `userHasScrolled` should be `false` (but will be `true` with current bug)
- [ ] **RUN TEST** ‚Äî verify it FAILS with current code ‚ö†Ô∏è
- [ ] Document failure output (same error users see)

**GREEN Phase:**
- [ ] Fix `MessageDisplay.js` line 182-185:
  - Replace `setTimeout(() => { ... }, 0)` with `requestAnimationFrame(() => { ... })`
- [ ] **RUN TEST** ‚Äî verify it PASSES ‚úÖ

**Files affected:**
- Test: `tests/message-display-scrolling.test.js`
- Code: `src/webview/app/components/MessageDisplay/MessageDisplay.js` (lines 182-185)

---

#### 2.3 TDD: Test for ResizeObserver False Positives

**RED Phase:**
- [ ] Write test: "should not auto-scroll when input area resizes"
- [ ] Setup: Create MessageDisplay with user scrolled up (not at bottom)
- [ ] Simulate: Resize `<main>` element (mimics input area expansion)
- [ ] Assert: Scroll position should NOT change (but currently auto-scrolls)
- [ ] **RUN TEST** ‚Äî verify it FAILS with current code ‚ö†Ô∏è
- [ ] Document failure output

**GREEN Phase:**
- [ ] Replace `ResizeObserver` with `MutationObserver` in `MessageDisplay.js` lines 98-120:
  ```javascript
  setupAutoScroll() {
      if (!this.messagesContainer) return;
      
      this.mutationObserver = new MutationObserver((mutations) => {
          const hasNewChildren = mutations.some(m => m.addedNodes.length > 0);
          if (hasNewChildren) {
              clearTimeout(this.scrollTimeout);
              this.scrollTimeout = setTimeout(() => this.autoScroll(), 50);
          }
      });
      
      this.mutationObserver.observe(this.messagesContainer, {
          childList: true,
          subtree: false
      });
  }
  ```
- [ ] Update `cleanup()` to disconnect `mutationObserver` instead of `resizeObserver`
- [ ] **RUN TEST** ‚Äî verify it PASSES ‚úÖ

**Files affected:**
- Test: `tests/message-display-scrolling.test.js`
- Code: `src/webview/app/components/MessageDisplay/MessageDisplay.js` (lines 98-120)

---

#### 2.4 TDD: Test for Auto-Scroll on New Message

**RED Phase:**
- [ ] Write test: "should auto-scroll when new message added and near bottom"
- [ ] Setup: MessageDisplay at bottom
- [ ] Action: Add new message via `addMessage()`
- [ ] Assert: Should scroll to new bottom (this should work, but test proves it)
- [ ] Write test: "should NOT auto-scroll when user scrolled up"
- [ ] Setup: MessageDisplay scrolled up 200px
- [ ] Action: Add new message
- [ ] Assert: Scroll position unchanged
- [ ] **RUN TESTS** ‚Äî verify behavior against current code

**GREEN Phase:**
- [ ] Verify MutationObserver change (from 2.3) fixes this correctly
- [ ] **RUN TESTS** ‚Äî all pass ‚úÖ

**Files affected:**
- Test: `tests/message-display-scrolling.test.js`

---

#### 2.5 Remove Console.log Statements

- [ ] Find all `console.log` in `MessageDisplay.js` (12+ instances)
- [ ] Replace with debug utility:
  ```javascript
  const DEBUG_SCROLL = false;
  function scrollLog(...args) {
      if (DEBUG_SCROLL) console.log('[Scroll]', ...args);
  }
  ```
- [ ] Replace all scroll-related `console.log` calls with `scrollLog()`
- [ ] Set `DEBUG_SCROLL = false` for production

**Files affected:**
- Modified: `src/webview/app/components/MessageDisplay/MessageDisplay.js` (lines 79-176)

---

#### 2.6 Consolidate clear() and clearMessages()

**Current:**
- `clearMessages()` (line 203): uses `innerHTML = ''` ‚Äî destroys everything
- `clear()` (line 282): uses `querySelectorAll().forEach(remove)` ‚Äî preserves empty state

- [ ] Remove `clearMessages()` method entirely
- [ ] Keep `clear()` method as the single implementation:
  ```javascript
  clear() {
      const messages = this.messagesContainer.querySelectorAll('.message-display__item');
      messages.forEach(msg => msg.remove());
      this.toolExecution?.clear();
      if (this.emptyState) this.emptyState.style.display = 'flex';
      this.userHasScrolled = false;
  }
  ```
- [ ] Find all usages of `clearMessages()` and replace with `clear()`
- [ ] Test: verify clearing works correctly

**Files affected:**
- Modified: `src/webview/app/components/MessageDisplay/MessageDisplay.js` (lines 203-212, 282-291)

---

#### 2.7 Remove Local escapeHtml Reimplementation

**Current:**
- Line 1: imports `escapeHtml` from `webview-utils.js`
- Line 276: defines local `escapeHtml` method using different technique

- [ ] Remove local `escapeHtml` method (line 276)
- [ ] Ensure all usages use the imported `escapeHtml` from utils
- [ ] Test: verify HTML escaping works correctly

**Files affected:**
- Modified: `src/webview/app/components/MessageDisplay/MessageDisplay.js` (line 276)

---

### Phase 2 Success Criteria

- [ ] All tests written BEFORE fixes (TDD RED phase)
- [ ] All tests failed against buggy code (documented)
- [ ] All tests pass after fixes (TDD GREEN phase)
- [ ] `requestAnimationFrame` used instead of `setTimeout`
- [ ] `MutationObserver` used instead of `ResizeObserver` on `<main>`
- [ ] Zero `console.log` statements in hot paths (or gated by DEBUG flag)
- [ ] Single `clear()` method (no duplication)
- [ ] No local reimplementations of imported utilities
- [ ] Scrolling "just works" ‚Äî manual testing confirms no user-reported bugs
- [ ] All existing tests still pass

---

## Phase 3: Sidebar View (WebviewViewProvider)

### Problem Statement

**Current:** Extension uses `WebviewPanel` which creates editor tabs  
**Target:** Use `WebviewViewProvider` for native sidebar experience

**Impact:**
- Chat panel competes with editor tabs (poor UX)
- Cannot be dragged to secondary sidebar
- Less native feel compared to Claude Code, GitHub Copilot

**Approach:**
- Already documented in `planning/3.0/sidebar-view-refactor.md`
- Convert from `createWebviewPanel()` to `registerWebviewViewProvider()`
- Add activity bar icon and view contributions
- Maintain all existing functionality
- This is a clean cut ‚Äî sidebar is objectively better

---

### Tasks: Phase 3

#### 3.1 Add Package.json Contributions

- [ ] Add `viewsContainers` contribution:
  ```json
  "viewsContainers": {
      "activitybar": [
          {
              "id": "copilot-cli-sidebar",
              "title": "Copilot CLI",
              "icon": "images/sidebar-icon.svg"
          }
      ]
  }
  ```
- [ ] Add `views` contribution:
  ```json
  "views": {
      "copilot-cli-sidebar": [
          {
              "type": "webview",
              "id": "copilot-cli.chatView",
              "name": "Chat",
              "icon": "$(comment-discussion)",
              "contextualTitle": "Copilot CLI"
          }
      ]
  }
  ```
- [ ] Create/add `images/sidebar-icon.svg` (activity bar icon)

**Files affected:**
- Modified: `package.json`
- New: `images/sidebar-icon.svg`

---

#### 3.2 Refactor ChatViewProvider to Implement WebviewViewProvider

**Current:** `createWebviewPanel()` returns `WebviewPanel`  
**Target:** `resolveWebviewView()` receives `WebviewView`

- [ ] Change class signature: `export class ChatViewProvider implements vscode.WebviewViewProvider, vscode.Disposable`
- [ ] Replace `createOrShow()` method with `resolveWebviewView()`:
  ```typescript
  public resolveWebviewView(
      webviewView: vscode.WebviewView,
      context: vscode.WebviewViewResolveContext,
      token: vscode.CancellationToken
  ): void {
      this._view = webviewView;
      
      webviewView.webview.options = {
          enableScripts: true,
          localResourceRoots: [this._extensionUri]
      };
      
      webviewView.webview.html = this.getHtmlForWebview(webviewView.webview);
      this.setupMessageHandlers(webviewView.webview);
  }
  ```
- [ ] Replace all `panel` references with `view`
- [ ] Update visibility/disposal handlers
- [ ] Keep all message passing logic (mostly unchanged)

**Files affected:**
- Modified: `src/chatViewProvider.ts` (entire class refactor)

---

#### 3.3 Update Extension Registration

- [ ] Replace `createOrShow()` command logic with `vscode.commands.executeCommand('copilot-cli.chatView.focus')`
- [ ] Register provider in `extension.ts`:
  ```typescript
  const chatProvider = new ChatViewProvider(context.extensionUri);
  context.subscriptions.push(
      vscode.window.registerWebviewViewProvider(
          'copilot-cli.chatView',
          chatProvider
      )
  );
  ```
- [ ] Update all commands to work with sidebar view
- [ ] Test: `openChat` command reveals sidebar

**Files affected:**
- Modified: `src/extension.ts`

---

#### 3.4 Update CSS for Sidebar Width

- [ ] Test webview at various sidebar widths (200px - 600px)
- [ ] Add responsive CSS for narrower widths if needed
- [ ] Verify all components render correctly in sidebar
- [ ] Test drag to secondary sidebar

**Files affected:**
- Modified: `src/webview/app/styles.css` (if needed)

---

#### 3.5 Test All Features in Sidebar View

- [ ] Message sending/receiving
- [ ] Tool execution visualization
- [ ] Plan mode toggle
- [ ] Session switching
- [ ] Attachment handling
- [ ] Markdown rendering
- [ ] **CRITICAL**: Drag to secondary sidebar works ‚ú®
- [ ] Session state persists across view hide/show

**Files affected:**
- Manual testing checklist

---

### Phase 3 Success Criteria

- [ ] Extension appears in VS Code activity bar with custom icon
- [ ] Chat view opens in primary sidebar by default
- [ ] Users can drag chat view to secondary sidebar ‚ú®
- [ ] All existing features work identically
- [ ] No regressions in session management
- [ ] All 90+ existing tests pass
- [ ] UI looks good at various sidebar widths (200px - 600px)
- [ ] BackendState correctly survives view hide/show
- [ ] Documentation updated (README, CHANGELOG)

---

## Phase 4: VS Code Chat APIs (DEFERRED)

**Not included in this plan.** Future discussion will cover:
- Chat Participant API (`@copilot-cli`)
- Chat Output Renderers (custom tool execution visualizations)
- Session Controller API (native session management)

This phase requires engine bump to `^1.109.0` and `enabledApiProposals`. Some APIs are still proposed (not finalized).

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Phase 1 event refactor introduces regressions | High | 90+ existing tests provide safety net; comprehensive manual testing |
| Phase 2 scrolling tests are flaky (JSDOM timing) | Medium | Use `requestAnimationFrame` shim; add delays if needed |
| Phase 3 sidebar breaks user workflows | Low | Clean cut is fine ‚Äî sidebar is objectively better |
| Event system changes affect plan mode | Medium | Plan mode uses same event flow; test dual-session switching |
| Memory leaks not fully eliminated | Medium | Manual testing with Chrome DevTools; monitor extension host memory |

---

## Testing Strategy

### Phase 1: Foundational (Permission to Fix)
- Run all 90+ existing tests after each task
- Manual testing: session switching, plan mode, message flow
- Monitor for memory leaks (Chrome DevTools ‚Üí Extension Host)
- Test startup race: rapid session start scenarios
- Verify no dropped messages on startup

### Phase 2: Scrolling (TDD Required)
- **RED**: Write failing test first
- **VERIFY FAILURE**: Run test against current buggy code, document error
- **GREEN**: Fix the code
- **VERIFY PASS**: Run test again, verify it passes
- Integration tests: manual scrolling in built extension
- Test auto-scroll, user-scroll, programmatic scroll

### Phase 3: Sidebar (Integration Testing)
- Build and install VSIX after changes
- Test all features manually in sidebar view
- Test drag to secondary sidebar
- Test session persistence across view hide/show
- Test at various sidebar widths
- Run all existing tests (should pass without modification)

---

## Implementation Order

1. **Phase 1** (3-5 days)
   - Task 1.1: Create disposable utilities
   - Task 1.2: Convert ChatPanelProvider to instance
   - Task 1.3: Split onMessage into granular events
   - Task 1.4: Implement EventRelay
   - Task 1.5: Add BufferedEmitter
   - Task 1.6: Fix session unsubscribe
   - Task 1.7: Add error boundaries
   - Task 1.8: Fix PlanModeToolsService

2. **Phase 2** (2-3 days)
   - Task 2.1: Setup JSDOM test environment
   - Task 2.2: TDD for setTimeout race
   - Task 2.3: TDD for ResizeObserver false positives
   - Task 2.4: TDD for auto-scroll behavior
   - Task 2.5: Remove console.log
   - Task 2.6: Consolidate clear methods
   - Task 2.7: Remove escapeHtml reimplementation

3. **Phase 3** (3-4 days)
   - Task 3.1: Add package.json contributions
   - Task 3.2: Refactor to WebviewViewProvider
   - Task 3.3: Update extension registration
   - Task 3.4: Update CSS for sidebar
   - Task 3.5: Test all features

**Total Estimated Time:** 8-12 days

---

## Success Metrics

**Phase 1:**
- [ ] Zero memory leaks from event subscriptions
- [ ] No dropped messages on startup
- [ ] All event handlers have error boundaries
- [ ] 87-line switch eliminated
- [ ] All 90+ tests pass

**Phase 2:**
- [ ] All tests written BEFORE fixes
- [ ] All tests failed first (RED), then passed (GREEN)
- [ ] Scrolling works flawlessly in manual testing
- [ ] Zero console.log spam
- [ ] No code duplication

**Phase 3:**
- [ ] Extension in activity bar with icon
- [ ] Sidebar view works perfectly
- [ ] Draggable to secondary sidebar ‚ú®
- [ ] All features work identically
- [ ] All tests pass

---

## Open Questions

1. **EventRelay vs direct relay pattern** ‚Äî Should we use VS Code's internal `Relay<T>` pattern or our own simplified version?
   - Recommendation: Start with simplified version, refine if needed

2. **BufferedEmitter buffer size** ‚Äî Should we limit buffer size or allow unlimited?
   - Recommendation: Unlimited for now (startup race is short-lived)

3. **Error boundaries user notification** ‚Äî Show error dialog or just log?
   - Recommendation: Log + show notification for critical failures only

4. **Sidebar icon design** ‚Äî Use existing icon or create custom?
   - Recommendation: Use built-in `$(comment-discussion)` for now, custom icon later

5. **CSS breakpoints for sidebar** ‚Äî What widths should we test?
   - Recommendation: 200px (minimum), 300px (narrow), 400px (default), 600px (wide)

---

## Notes

- **Permission granted for Phase 1**: Fix foundational issues without strict TDD ‚Äî structural refactoring
- **TDD required for Phase 2**: Write failing tests first, watch them fail, then fix
- **No external code**: Just us and main.js ‚Äî breaking changes are fine
- **Phase 4 deferred**: Chat Participant, Output Renderers, Session Controller ‚Äî future discussion
- External audit by Claude Code deep research session (2026-02-12)
- Total codebase: ~1,950 production lines, ~10,000 test lines
- Test coverage: 90+ test files, 5:1 test/code ratio

---

## External Review: Second Opinion (Claude Opus 4.6, 2026-02-12)

### Scope

Fresh session asked to review all code review documents (`planning/3.0/code_review/*`), the current source code, the progress document, and the EventRelay design decision. Below are findings organized by severity.

---

### BLOCKER: Task Completion vs. Actual Code State

**Several tasks are marked COMPLETE but the corresponding code changes were never applied to `sdkSessionManager.ts`.**

I verified this by searching `sdkSessionManager.ts` for the artifacts each task should have produced:

| Task | Claimed Status | Artifact Expected | Found in Code? |
| --- | --- | --- | --- |
| 1.1 Disposable utilities | COMPLETE | `src/utilities/disposable.ts` | YES - file exists, correct |
| 1.2 ChatPanelProvider instance | COMPLETE | Instance-based class, no static members | YES - `chatViewProvider.ts` modified in git diff |
| 1.3 Granular events on SDKSessionManager | COMPLETE | `_onDidReceiveOutput`, `onDidReceiveOutput`, `DisposableStore`, `_reg` helper | **NO** - none of these exist in `sdkSessionManager.ts` |
| 1.6 MutableDisposable for session sub | COMPLETE | `MutableDisposable`, `toDisposable` import | **NO** - still uses `sessionUnsubscribe: (() => void) \| null` |

**Impact:** `extension.ts` was updated to call `cliManager.onDidReceiveOutput(...)` and 9 other granular event methods. These methods do not exist on `SDKSessionManager`. The extension will crash on activation with `TypeError: cliManager.onDidReceiveOutput is not a function`.

**Root cause:** It appears the `extension.ts` consumer side was written first (replacing the switch statement with granular subscriptions), but the producer side (`sdkSessionManager.ts`) was never updated to expose those events.

---

### BLOCKER: Status Event Handlers Dropped from extension.ts

When `extension.ts` was refactored from the monolithic `onMessage` switch to granular events, the `onDidChangeStatus` handler lost most status type handling. The old switch had explicit handlers for:

**Missing status handlers (were present in old code, absent in new code):**

- `exited` / `stopped` - Updated status bar, set session inactive, notified user
- `aborted` - Showed "Generation stopped by user" message, cleared thinking state
- `session_expired` - Updated backend state with new session ID, showed visual separator, triggered session list update
- `plan_mode_enabled` / `plan_mode_disabled` - Forwarded to webview via `postMessage`
- `plan_accepted` / `plan_rejected` - Forwarded to webview via `postMessage`
- `reset_metrics` - Forwarded to webview via `postMessage`
- `plan_ready` - Forwarded to webview via `postMessage`

**The new code only handles:** `thinking` and `ready`.

**Impact:** Plan mode toggle won't update the UI. Aborting a message won't show feedback. Session expiry recovery is broken. Metrics reset is broken.

---

### ISSUE: Task 1.4 Description is Copy-Pasted from Task 1.3

The document has two entries for "Task 1.4." The first (line 164) is a copy of Task 1.3's description ("Split SDKSessionManager onMessage into Granular Events") with unchecked boxes. The second (line 194) is the actual EventRelay task. This is confusing and should be cleaned up.

---

### NOTE: EventRelay Design Decision

Full analysis written in `planning/in-progress/EVENTRELAY-DESIGN-DECISION.md`.

**Short version:** Choose **Option C (MutableDisposable)**. The granular emitters from Task 1.3, once actually applied, already serve as the stable relay point. EventRelay adds 30 objects (20 intermediate emitters + 10 relays) to solve a problem that doesn't exist once the granular events are in place. Keep the EventRelay utility in the codebase for potential future use, but don't apply it to session switching.

See the full analysis for the architectural reasoning.

---

### Recommended Recovery Path

1. **Fix Task 1.3 for real.** Apply granular events to `sdkSessionManager.ts`:
   - Import `DisposableStore`, `MutableDisposable`, `toDisposable` from utilities
   - Add `_disposables`, `_sessionSub`, `_reg` helper
   - Create 10 granular `EventEmitter` fields + public event properties
   - Extract `_handleSDKEvent()` method from `setupSessionEventHandlers()`
   - Reduce `setupSessionEventHandlers()` to 4 lines using `MutableDisposable`
   - Keep `onMessage`/`onMessageEmitter` temporarily for plan mode status forwarding

2. **Fix the status handler regression in `extension.ts`.** Add back all the dropped status handlers into `onDidChangeStatus`. Every case from the old switch that handled `message.data.status` values needs to be restored.

3. **Mark Task 1.4 as COMPLETE** with the decision: "Option C chosen. Granular emitters serve as the relay mechanism. EventRelay utility retained but not applied to session switching."

4. **Clean up the duplicate Task 1.4 entry** (remove the copy-pasted Task 1.3 checklist).

5. **Verify the extension compiles** before proceeding to Tasks 1.5, 1.7, 1.8. The current code will not compile.

---

### What's Going Well

- **Task 1.1 (Disposable utilities):** Clean, correct implementation. `DisposableStore`, `MutableDisposable`, and `toDisposable` are exactly what VS Code extensions need.
- **Task 1.2 (ChatPanelProvider instance-based):** The conversion from static to instance-based with typed events is good. The `extension.ts` diff shows proper `context.subscriptions.push()` for all event handlers.
- **EventRelay utility:** Well-designed, well-tested (9/9 tests). The class itself is correct. The question was only about whether to apply it to session switching (answer: no).
- **Test coverage:** 9 EventRelay tests with good edge case coverage. The test strategy document shows thoughtful planning.
- **Architecture direction:** The overall direction (granular events, disposable chains, instance-based providers) is correct and aligns with VS Code extension best practices.
- **Documentation quality:** The design decision document is one of the best-structured technical decision docs I've seen. The problem statement, options analysis, and trade-offs are clear and honest.

---

### Summary

The plan is sound, the direction is correct, and the utilities are well-built. The main issues are:

1. A disconnect between what's marked complete and what's actually in the code
2. A regression in status event handling that would break multiple features
3. Over-engineering anxiety about EventRelay when the simpler Option C achieves the same goals

Fix the two blockers, choose Option C, and Phase 1 is in good shape to complete.
