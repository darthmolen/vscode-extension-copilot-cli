# Phase 3: Extract Backend Services - TDD Implementation Plan

## üìä Progress Tracking

**Overall Status: ‚úÖ Phase 0 Complete & Verified (2026-02-09)**

| Phase | Service | Status | Lines Saved | Tests Added | Notes |
|-------|---------|--------|-------------|-------------|-------|
| **Phase 0** | **PlanModeToolsService Enhancement** | ‚úÖ **VERIFIED** | **-119 lines** | **9 tests** | **Configuration abstraction tested & working in production** |
| Phase 1 | ConfigurationService | ‚è≥ Not Started | Target: -50 | Target: 6 | - |
| Phase 2 | SessionService | ‚è≥ Not Started | Target: -200 | Target: 12 | - |
| Phase 3 | StartupService | ‚è≥ Not Started | Target: -140 | Target: 8 | - |
| Phase 4 | CommandHandlerService | ‚è≥ Not Started | Target: -200 | Target: 12 | - |
| Phase 5 | ActiveFileTrackerService | ‚è≥ Optional | Target: -40 | Target: 7 | - |
| Phase 6 | Final Refactor - Organize All | ‚è≥ Not Started | N/A | N/A | Move all 10 services to `src/extension/services/` |

**Current Metrics:**
- sdkSessionManager.ts: ~~1568~~ ‚Üí **1449 lines** (-119, target: ~1450) ‚úÖ **TARGET MET!**
- extension.ts: Still 879 lines (target: ~200)
- chatViewProvider.ts: Still 539 lines (target: ~300)
- New tests: 9 (target: 54+)
- Services extracted: 5 existing + 1 enhanced = 6 total

---

## ‚ö° MANDATORY FIRST STEP ‚ö°

**REQUIRED: Activate using-superpowers and test-driven-development skills BEFORE starting ANY work**

This ensures:
- Established TDD workflows are followed (RED ‚Üí GREEN ‚Üí REFACTOR)
- Tests are written FIRST, production code SECOND
- Common mistakes and rework are prevented
- Quality and maintainability standards are maintained

## Status
üü¢ ~70% Complete (5 services extracted in v2.2+)

## Goal
Complete Phase 3 by extracting remaining services from monolithic `extension.ts` and enhancing existing services for better configuration abstraction, then organize all services into proper directory structure.

**Target Metrics:**
- extension.ts: 879 lines ‚Üí ~200 lines (77% reduction) üéØ
- sdkSessionManager.ts: 1568 lines ‚Üí ~1450 lines (7.5% reduction) üéØ
- chatViewProvider.ts: 539 lines ‚Üí ~300 lines (44% reduction) üéØ
- All services: 100% test coverage ‚úÖ
- All services: Organized in `src/extension/services/` ‚úÖ

## Completed Services ‚úÖ (v2.2+)

These services have already been extracted and are working (currently in `src/`):

1. **ModelCapabilitiesService** (`src/modelCapabilitiesService.ts`) - Model info caching, attachment validation
2. **MCPConfigurationService** (`src/mcpConfigurationService.ts`) - MCP server configuration management  
3. **PlanModeToolsService** (`src/planModeToolsService.ts`) - Plan mode tool implementations
4. **FileSnapshotService** (`src/fileSnapshotService.ts`) - File snapshot management
5. **MessageEnhancementService** (`src/messageEnhancementService.ts`) - Message formatting

**Note**: These will be moved to `src/extension/services/` in the final refactor step.

## Services to Extract/Enhance

### 0. Enhance PlanModeToolsService üéØ HIGHEST PRIORITY (Configuration Abstraction)

**Why this is Priority #1**: Removes hard-coding from sdkSessionManager and establishes pattern for configuration abstraction.

**Lines to extract**: ~118 lines from sdkSessionManager.ts (hard-coded arrays and prompts)

**Current location**: 
- Hard-coded availableTools array (sdkSessionManager.ts lines 1050-1065)
- Hard-coded system prompt (sdkSessionManager.ts lines 1066-1172)

**Responsibility**: Centralize ALL plan mode tool configuration and prompt engineering

**Why enhance?**
- ‚úÖ Removes 118 lines of hard-coding from sdkSessionManager
- ‚úÖ PlanModeToolsService becomes single source of truth for plan mode tool knowledge
- ‚úÖ Enables future UI customization of tools/prompts
- ‚úÖ Enables system prompt engineering/testing
- ‚úÖ Configuration abstraction pattern for other services

**New Methods to Add**:
```typescript
export class PlanModeToolsService {
    // Existing: getTools() - returns tool implementations
    
    /**
     * Get names of all available tools in plan mode
     * Includes custom tools (6) + whitelisted SDK tools (5)
     */
    getAvailableToolNames(): string[] {
        return [
            // Custom restricted tools (6)
            'plan_bash_explore',           // restricted bash for read-only commands
            'task_agent_type_explore',     // restricted task for exploration only
            'edit_plan_file',              // edit ONLY plan.md
            'create_plan_file',            // create ONLY plan.md
            'update_work_plan',            // update plan content
            'present_plan',                // present plan to user for acceptance
            // Safe SDK tools (5)
            'view',                        // read files
            'grep',                        // search content
            'glob',                        // find files
            'web_fetch',                   // fetch URLs
            'fetch_copilot_cli_documentation', // get CLI docs
            'report_intent'                // report intent to UI
        ];
    }
    
    /**
     * Generate plan mode system prompt with workspace-specific info
     * @param workSessionId - Work session ID for plan.md path resolution
     * @returns Complete system prompt for plan mode
     */
    getSystemPrompt(workSessionId: string): string {
        const planPath = path.join(
            require('os').homedir(), 
            '.copilot', 
            'session-state', 
            workSessionId, 
            'plan.md'
        );
        
        return `

---
üéØ **YOU ARE IN PLAN MODE** üéØ
---

Your role is to PLAN, not to implement. You have the following capabilities:

**YOUR PLAN LOCATION:**
Your plan is stored at: \`${planPath}\`
This is your dedicated workspace for planning.

**AVAILABLE TOOLS IN PLAN MODE (11 total):**

*Plan Management Tools:*
- \`update_work_plan\` - **PRIMARY TOOL** for creating/updating your implementation plan
- \`present_plan\` - **REQUIRED AFTER PLANNING** to present the plan to the user for review
- \`create_plan_file\` - Create plan.md if it doesn't exist (restricted to plan.md only)
- \`edit_plan_file\` - Edit plan.md (restricted to plan.md only)

*Exploration Tools:*
- \`view\` - Read file contents
- \`grep\` - Search in files
- \`glob\` - Find files by pattern
- \`plan_bash_explore\` - Execute read-only shell commands (git status, ls, cat, etc.)
- \`task_agent_type_explore\` - Dispatch exploration sub-agents (agent_type="explore" only)

*Documentation Tools:*
- \`web_fetch\` - Fetch web pages and documentation
- \`fetch_copilot_cli_documentation\` - Get Copilot CLI documentation

**CRITICAL: HOW TO CREATE YOUR PLAN**
You MUST use ONLY these tools to create/update your plan:

1. **update_work_plan** (PREFERRED) - Use this to create or update your plan:
   \`\`\`
   update_work_plan({ content: "# Plan\\n\\n## Problem...\\n\\n## Tasks\\n- [ ] Task 1" })
   \`\`\`

2. **present_plan** (REQUIRED) - After finalizing your plan, call this to present it to the user:
   \`\`\`
   present_plan({ summary: "Plan for implementing feature X" })
   \`\`\`
   This notifies the user that the plan is ready for review and acceptance.

3. **create_plan_file** (FALLBACK) - Only if update_work_plan fails, use create_plan_file with the exact path:
   \`\`\`
   create_plan_file({ 
     path: "${planPath}",
     file_text: "# Plan\\n\\n## Problem..."
   })
   \`\`\`

**WORKFLOW:**
1. Explore and analyze the codebase
2. Create/update your plan using \`update_work_plan\`
3. When the plan is complete and ready for user review, call \`present_plan\`
4. The user will then review and either accept, request changes, or provide new instructions

‚ùå DO NOT try to create files in /tmp or anywhere else
‚ùå DO NOT use bash to create the plan
‚úÖ ALWAYS use update_work_plan to create/update the plan
‚úÖ ALWAYS call present_plan when the plan is ready for review

**WHAT YOU CAN DO:**
- Analyze the codebase and understand requirements (use view, grep, glob tools)
- Ask questions to clarify the task (use ask_user if available)
- Research and explore the code structure (use task_agent_type_explore with agent_type="explore")
- Fetch documentation and web resources (use web_fetch)
- Run read-only commands to understand the environment (git status, ls, cat, etc. via plan_bash_explore)
- Design solutions and consider alternatives
- **Create and update implementation plans using update_work_plan**
- Document your thinking and reasoning

**WHAT YOU CANNOT DO:**
- You CANNOT use edit or other file modification tools (except for plan.md via update_work_plan/create)
- You CANNOT execute write commands (no npm install, git commit, rm, mv, etc.)
- You CANNOT make changes to the codebase
- You are in READ-ONLY mode for code

**BASH COMMAND RESTRICTIONS (ENFORCED):**
The bash tool is restricted to read-only commands. Attempts to run write commands will be automatically blocked.

Allowed commands:
- git status, git log, git branch, git diff, git show
- ls, cat, head, tail, wc, find, grep, tree, pwd
- npm list, pip list, go list
- which, whereis, ps, env, echo, date, uname

Blocked commands (will be rejected):
- git commit, git push, git checkout, git merge
- rm, mv, cp, touch, mkdir
- npm install, npm run, make, build commands
- sudo, chmod, chown

Your plan should include:
1. **Problem Statement**: Clear description of what needs to be done
2. **Approach**: Proposed solution and why it's the best approach
3. **Tasks**: Step-by-step implementation tasks with checkboxes [ ]
4. **Technical Considerations**: Important details, risks, dependencies
5. **Testing Strategy**: How to verify the implementation works

When the user is satisfied with the plan, they will toggle back to WORK MODE to implement it.
Remember: Your job is to think deeply and plan thoroughly, not to code!
`.trim();
    }
}
```

**TDD Approach**:
1. RED: Create test file `tests/plan-mode-tools-service-configuration.test.js`
2. RED: Write test for getAvailableToolNames() returns correct array
3. RED: Write test for getAvailableToolNames() returns 11 tools
4. RED: Write test for getSystemPrompt() generates prompt with correct plan path
5. RED: Write test for getSystemPrompt() includes all tool descriptions
6. RED: Run tests ‚Üí verify failures
7. GREEN: Implement getAvailableToolNames() in PlanModeToolsService
8. GREEN: Implement getSystemPrompt() in PlanModeToolsService
9. GREEN: Run tests ‚Üí verify passing
10. REFACTOR: Update sdkSessionManager.ts to use new methods
11. REFACTOR: Remove hard-coded arrays/prompts from sdkSessionManager
12. REFACTOR: Run all tests ‚Üí verify no regressions
13. INTEGRATION: Build and test with `./test-extension.sh`

**Tests to write** (plan-mode-tools-service-configuration.test.js):
- getAvailableToolNames() returns array of 11 tool names ‚úì
- getAvailableToolNames() includes all custom tools (6) ‚úì
- getAvailableToolNames() includes all SDK tools (5) ‚úì
- getAvailableToolNames() includes report_intent ‚úì
- getSystemPrompt() generates prompt with plan path ‚úì
- getSystemPrompt() includes correct session ID in path ‚úì
- getSystemPrompt() includes all tool descriptions ‚úì
- getSystemPrompt() includes workflow instructions ‚úì
- getSystemPrompt() includes restrictions ‚úì

**Benefits**:
- ‚úÖ Configuration abstraction (tools and prompts configurable)
- ‚úÖ Future UI for customization (tool selection, prompt editing)
- ‚úÖ System prompt engineering/testing enabled
- ‚úÖ sdkSessionManager becomes pure orchestration
- ‚úÖ PlanModeToolsService is single source of truth

---

### 1. SessionService üéØ HIGH PRIORITY
**Lines to extract**: ~200 from extension.ts

**Responsibility**: Session lifecycle management

**Current location**: Functions scattered in extension.ts:
- `determineSessionToResume()` (lines 369-389)
- `updateSessionsList()` (lines 658-716)
- `formatSessionLabel()` (lines 718-741)
- Session switching logic in command handlers

**Interface** (from phase-3 plan):
```typescript
export interface ISessionService {
  createSession(): Promise<Session>;
  deleteSession(sessionId: string): Promise<void>;
  getSession(sessionId: string): Session | undefined;
  getActiveSession(): Session | undefined;
  setActiveSession(sessionId: string): void;
  listSessions(): Session[];
  getSessionStateDir(sessionId: string): string;
  
  // Additional methods needed:
  determineSessionToResume(context: ExtensionContext): Promise<string | null>;
  formatSessionLabel(sessionId: string, sessionPath: string): string;
  loadSessionHistory(sessionId: string): Promise<Message[]>;
}
```

**Why extract?**
- Session management is a core domain concern
- Currently scattered across 200+ lines in extension.ts
- Hard to test in current location
- Clear single responsibility

**TDD Approach**:
1. RED: Write tests for session list formatting
2. RED: Write tests for session determination logic
3. RED: Write tests for history loading
4. RED: Write tests for label extraction from plan.md
5. GREEN: Create SessionService with minimal implementation
6. GREEN: Extract logic from extension.ts
7. REFACTOR: Clean up, optimize, remove duplication
8. INTEGRATION: Wire into extension.ts, test end-to-end

**Tests to write** (session-service.test.js):
- Determine session to resume with folder filtering ‚úì
- Determine session to resume without folder filtering ‚úì
- Handle no workspace open ‚úì
- Format session label with plan.md title ‚úì
- Format session label without plan.md (fallback to ID) ‚úì
- Load session history from events.jsonl ‚úì
- Handle missing events.jsonl ‚úì
- Parse user.message and assistant.message events ‚úì
- Skip malformed JSON lines ‚úì
- List all sessions with metadata ‚úì
- Filter sessions by workspace folder ‚úì
- Get most recent session ‚úì

---

### 2. ConfigurationService üî• MEDIUM PRIORITY
**Lines to extract**: ~50 from extension.ts + scattered reads

**Responsibility**: Centralized configuration management

**Current location**: 
- `getCLIConfig()` (lines 636-656)
- Scattered `vscode.workspace.getConfiguration('copilotCLI')` calls throughout

**Interface**:
```typescript
export interface IConfigurationService {
  getCLIConfig(): CLIConfig;
  getYoloMode(): boolean;
  getAllowAllTools(): boolean;
  getAllowAllPaths(): boolean;
  getAllowAllUrls(): boolean;
  getModel(): string;
  getPlanModel(): string;
  getResumeLastSession(): boolean;
  getFilterSessionsByFolder(): boolean;
  getIncludeActiveFile(): boolean;
  getGhSsoEnterpriseSlug(): string;
  
  // Event-based updates
  onConfigurationChanged(handler: (config: CLIConfig) => void): void;
}
```

**Why extract?**
- Configuration access scattered across files
- YOLO mode override logic is complex
- Hard to test configuration-dependent code
- Enables easier mocking in tests

**TDD Approach**:
1. RED: Write tests for getCLIConfig() logic
2. RED: Write tests for YOLO mode overrides
3. RED: Write tests for configuration defaults
4. GREEN: Create ConfigurationService
5. GREEN: Extract from extension.ts
6. REFACTOR: Replace scattered config reads with service
7. INTEGRATION: Update all files using config

**Tests to write** (configuration-service.test.js):
- Get CLI config with YOLO mode enabled (overrides all) ‚úì
- Get CLI config with YOLO mode disabled ‚úì
- Get individual config values ‚úì
- Handle missing config (defaults) ‚úì
- Configuration change event fires ‚úì
- YOLO overrides allowAllTools, allowAllPaths, allowAllUrls ‚úì

---

### 3. StartupService üî• MEDIUM PRIORITY  
**Lines to extract**: ~140 from extension.ts

**Responsibility**: Extension and session initialization/startup logic

**Current location**:
- `startCLISession()` (lines 391-634) - 244 lines!
- Auth error handling logic
- Session recovery dialogs

**Interface**:
```typescript
export interface IStartupService {
  startCLISession(
    resumeLastSession: boolean, 
    specificSessionId?: string
  ): Promise<void>;
  
  handleAuthenticationError(error: Error): Promise<void>;
  handleSessionExpiredError(sessionId: string, newSessionId: string): void;
  
  registerMessageHandlers(): void;
  setupStatusBar(): void;
}
```

**Why extract?**
- startCLISession is 244 lines - too complex for extension.ts
- Auth error handling is complex business logic
- Hard to test startup paths
- Multiple failure modes need testing

**TDD Approach**:
1. RED: Write tests for successful session start
2. RED: Write tests for resume vs. new session
3. RED: Write tests for auth error handling (Scenario 1 & 2)
4. RED: Write tests for session expired handling
5. GREEN: Create StartupService
6. GREEN: Extract from extension.ts
7. REFACTOR: Simplify error handling paths
8. INTEGRATION: Thin wrapper in extension.ts

**Tests to write** (startup-service.test.js):
- Start new session successfully ‚úì
- Resume last session successfully ‚úì
- Resume specific session by ID ‚úì
- Handle auth error - no env var (Scenario 1) ‚úì
- Handle auth error - invalid env var (Scenario 2) ‚úì
- Handle session expired error ‚úì
- Setup status bar indicator ‚úì
- Register message handlers once ‚úì

---

### 4. CommandHandlerService üí° MEDIUM PRIORITY
**Lines to extract**: ~200 from extension.ts

**Responsibility**: Command registration and orchestration

**Current location**: extension.ts activate() function (lines 31-363)

**Interface**:
```typescript
export interface ICommandHandlerService {
  registerCommands(context: ExtensionContext): void;
  
  // Individual command handlers (private)
  private handleOpenChat(): Promise<void>;
  private handleStartChat(): Promise<void>;
  private handleNewSession(): Promise<void>;
  private handleSwitchSession(sessionId: string): Promise<void>;
  private handleStopChat(): Promise<void>;
  private handleRefreshPanel(): void;
  private handleViewDiff(message: any): Promise<void>;
  private handleTogglePlanMode(enabled: boolean): Promise<void>;
  private handleAcceptPlan(): Promise<void>;
  private handleRejectPlan(): Promise<void>;
}
```

**Why extract?**
- 10+ commands registered inline in activate()
- Hard to test command logic
- Would simplify extension.ts significantly
- Command handlers have business logic that should be tested

**TDD Approach**:
1. RED: Write tests for each command handler
2. RED: Write tests for command orchestration
3. RED: Write tests for error handling in commands
4. GREEN: Create CommandHandlerService
5. GREEN: Extract command handlers
6. REFACTOR: Simplify activate() to just call registerCommands()
7. INTEGRATION: Verify all commands still work

**Tests to write** (command-handler-service.test.js):
- Register all commands ‚úì
- Open chat command ‚úì
- Start chat command ‚úì
- New session command (stops existing, starts new) ‚úì
- Switch session command ‚úì
- Stop chat command ‚úì
- Refresh panel command ‚úì
- View diff command ‚úì
- Toggle plan mode command ‚úì
- Accept plan command ‚úì
- Reject plan command ‚úì
- Error handling in each command ‚úì

---

### 5. ActiveFileTrackerService üí° LOW PRIORITY (Optional)
**Lines to extract**: ~40 from extension.ts

**Responsibility**: Track active file changes and normalize paths

**Current location**: extension.ts `updateActiveFile()` (lines 825-863)

**Interface**:
```typescript
export interface IActiveFileTrackerService {
  updateActiveFile(editor: vscode.TextEditor | undefined): void;
  getActiveFilePath(): string | null;
  clearActiveFile(): void;
  
  private normalizeToWorkspace(filePath: string): string;
  private shouldIncludeActiveFile(): boolean;
}
```

**Why extract?**
- Path normalization is complex
- Configuration-dependent behavior (includeActiveFile)
- File tracking state management
- Currently tightly coupled to BackendState

**TDD Approach**:
1. RED: Write tests for path normalization
2. RED: Write tests for editor state handling
3. RED: Write tests for configuration respect
4. GREEN: Create service
5. GREEN: Extract logic
6. REFACTOR: Clean up
7. INTEGRATION: Wire to extension.ts

**Tests to write** (active-file-tracker-service.test.js):
- Normalize workspace-relative path ‚úì
- Handle absolute path ‚úì
- Respect includeActiveFile setting (enabled) ‚úì
- Respect includeActiveFile setting (disabled) ‚úì
- Keep last known file when focus moves to webview ‚úì
- Clear when all editors close ‚úì
- Handle undefined editor ‚úì

---

## Services NOT Needed (Analysis)

Per the phase-3 plan, these were proposed but analysis shows they're not needed:

### ‚ùå CopilotService
**Why NOT extract**: SDKSessionManager already serves this purpose. It's a well-designed wrapper around the Copilot SDK with clear boundaries. Creating another abstraction layer would be over-engineering.

### ‚ùå CliServerService
**Why NOT extract**: Not applicable - we use SDK mode, not CLI server mode. This was speculative in the original plan.

### ‚ùå ToolPermissionService
**Why NOT extract**: No tool approval UI implemented yet. When we add this feature (future), we'll extract it then. Don't create services speculatively.

### ‚ùå PlanModeService (Full Service)
**Why NOT extract**: Only ~150 lines could actually move (other 150 tightly coupled to SDK client). Instead, **enhance PlanModeToolsService** with configuration methods. This gives us benefits (configuration abstraction) without costs (over-engineering, tight coupling).

---

## TDD Workflow (MANDATORY - Follow for EVERY Service)

### Phase 1: RED (Write Failing Tests)
1. Create test file: `tests/<service-name>.test.js`
2. Write ALL test cases for the service (see lists above)
3. Import the service (which doesn't exist yet)
4. Run tests ‚Üí **VERIFY THEY FAIL** (module not found)
5. Review test coverage - did we cover all edge cases?

### Phase 2: GREEN (Make Tests Pass)
1. Create service file: `src/extension/services/<ServiceName>.ts`
2. Implement **MINIMAL** code to make tests pass
3. Extract code from extension.ts
4. Run tests ‚Üí **VERIFY THEY ALL PASS**
5. No refactoring yet! Just get to green!

### Phase 3: REFACTOR (Clean Up)
1. Optimize implementation
2. Remove duplicate code
3. Improve naming and clarity
4. Extract helper methods
5. Add JSDoc comments
6. Run tests ‚Üí **VERIFY STILL PASSING**
7. Update extension.ts to use service (remove old code)
8. Run **ALL** tests ‚Üí **NO REGRESSIONS**

### Phase 4: INTEGRATION (Validate in Extension)
1. Wire service into extension.ts
2. Update imports and dependencies
3. Build and install: `./test-extension.sh`
4. Manual verification checklist (see below)
5. Check logs for errors
6. Integration tests if needed

---

## Implementation Order

Extract/enhance services in this order (based on dependencies):

0. **PlanModeToolsService Enhancement** - Configuration abstraction pattern (FIRST!)
1. **ConfigurationService** - No dependencies, used by others
2. **SessionService** - Depends on ConfigurationService, uses sessionUtils
3. **StartupService** - Depends on SessionService, ConfigurationService
4. **CommandHandlerService** - Depends on all services
5. **ActiveFileTrackerService** - Independent, can be done anytime (optional)

---

## Workplan

### Phase 0: Enhance PlanModeToolsService (Configuration Abstraction) üéØ ‚úÖ COMPLETE
- [x] RED: Create `tests/plan-mode-tools-service-configuration.test.js`
- [x] RED: Write 9 test cases (tool names, prompt generation)
- [x] RED: Run tests ‚Üí verify failures (9 failing tests confirmed)
- [x] GREEN: Add `getAvailableToolNames()` to PlanModeToolsService
- [x] GREEN: Add `getSystemPrompt(workSessionId)` to PlanModeToolsService
- [x] GREEN: Run tests ‚Üí verify passing (all 9 tests pass)
- [x] REFACTOR: Update sdkSessionManager.ts lines 1050-1065 (use getAvailableToolNames())
- [x] REFACTOR: Update sdkSessionManager.ts lines 1066-1172 (use getSystemPrompt())
- [x] REFACTOR: Remove hard-coded arrays and prompt from sdkSessionManager
- [x] REFACTOR: Run all tests ‚Üí verify no regressions (12/12 integration tests pass)
- [x] Integration: Build and test with `./test-extension.sh` (successful)
- [x] Verify plan mode still works (toggle, create plan, accept/reject) - ‚úÖ **USER VERIFIED (2026-02-09)**

**Phase 0 Summary - Completed & Verified 2026-02-09:**
- ‚úÖ **Configuration Abstraction Pattern Established**
  - Added 2 new methods to PlanModeToolsService: `getAvailableToolNames()` and `getSystemPrompt()`
  - PlanModeToolsService is now single source of truth for ALL plan mode configuration
  - Removed all hard-coded tool lists and system prompts from sdkSessionManager.ts
- ‚úÖ **Code Reduction Achieved**
  - sdkSessionManager.ts: 1568 ‚Üí 1449 lines (**-119 lines, -7.6% reduction**)
  - Exactly as planned! Target was -118 lines (-7.5%)
- ‚úÖ **TDD Discipline Followed**
  - RED: 9 failing tests written first
  - GREEN: Minimal implementation to pass all tests
  - REFACTOR: Integrated into production code without regressions
  - All 12 integration tests still passing
- ‚úÖ **Test Coverage**
  - 9 new unit tests for configuration methods
  - Tests verify: tool count (12), tool names, system prompt generation, path resolution
- ‚úÖ **Future-Ready**
  - Configuration can now be customized via UI (future enhancement)
  - System prompts can be engineered/tested independently
  - Pattern established for other services to follow
- ‚úÖ **Production Verified (2026-02-09)**
  - Extension built and installed successfully
  - Plan mode tested in production: toggle, create plan, present plan, accept plan
  - All functionality working as expected
  - Log file: `tests/logs/server/plan-mode-3.0-sucessful.log`

---

### Phase 1: ConfigurationService
- [ ] RED: Create `tests/configuration-service.test.js`
- [ ] RED: Write 6 test cases (YOLO, defaults, change events, etc.)
- [ ] RED: Run tests ‚Üí verify failures
- [ ] GREEN: Create `src/extension/services/ConfigurationService.ts`
- [ ] GREEN: Extract `getCLIConfig()` and scattered config reads
- [ ] GREEN: Run tests ‚Üí verify passing
- [ ] REFACTOR: Replace all scattered config reads
- [ ] REFACTOR: Run all tests ‚Üí verify no regressions
- [ ] Integration: Build and test with `./test-extension.sh`

### Phase 2: SessionService
- [ ] RED: Create `tests/session-service.test.js`
- [ ] RED: Write 12 test cases (listed above)
- [ ] RED: Run tests ‚Üí verify failures
- [ ] GREEN: Create `src/extension/services/SessionService.ts`
- [ ] GREEN: Extract determineSessionToResume, updateSessionsList, formatSessionLabel, loadSessionHistory
- [ ] GREEN: Run tests ‚Üí verify passing
- [ ] REFACTOR: Clean up implementation
- [ ] REFACTOR: Update extension.ts to use service
- [ ] REFACTOR: Run all tests ‚Üí verify no regressions
- [ ] Integration: Build and test with `./test-extension.sh`

### Phase 3: StartupService
- [ ] RED: Create `tests/startup-service.test.js`
- [ ] RED: Write 8 test cases (listed above)
- [ ] RED: Run tests ‚Üí verify failures
- [ ] GREEN: Create `src/extension/services/StartupService.ts`
- [ ] GREEN: Extract startCLISession, auth error handlers
- [ ] GREEN: Run tests ‚Üí verify passing
- [ ] REFACTOR: Simplify error handling paths
- [ ] REFACTOR: Update extension.ts to use service
- [ ] REFACTOR: Run all tests ‚Üí verify no regressions
- [ ] Integration: Build and test with `./test-extension.sh`

### Phase 4: CommandHandlerService
- [ ] RED: Create `tests/command-handler-service.test.js`
- [ ] RED: Write 12 test cases (listed above)
- [ ] RED: Run tests ‚Üí verify failures
- [ ] GREEN: Create `src/extension/services/CommandHandlerService.ts`
- [ ] GREEN: Extract all command handlers from activate()
- [ ] GREEN: Run tests ‚Üí verify passing
- [ ] REFACTOR: Simplify activate() to just registerCommands()
- [ ] REFACTOR: Update extension.ts
- [ ] REFACTOR: Run all tests ‚Üí verify no regressions
- [ ] Integration: Build and test with `./test-extension.sh`

### Phase 5: ActiveFileTrackerService (Optional)
- [ ] RED: Create `tests/active-file-tracker-service.test.js`
- [ ] RED: Write 7 test cases (listed above)
- [ ] RED: Run tests ‚Üí verify failures
- [ ] GREEN: Create `src/extension/services/ActiveFileTrackerService.ts`
- [ ] GREEN: Extract updateActiveFile logic
- [ ] GREEN: Run tests ‚Üí verify passing
- [ ] REFACTOR: Clean up implementation
- [ ] REFACTOR: Update extension.ts to use service
- [ ] REFACTOR: Run all tests ‚Üí verify no regressions
- [ ] Integration: Build and test with `./test-extension.sh`

### Phase 6: Final Refactor - Organize All Services üéØ
**Goal**: Move all services (existing + new) to `src/extension/services/` directory

**Services to move**:
1. `src/modelCapabilitiesService.ts` ‚Üí `src/extension/services/ModelCapabilitiesService.ts`
2. `src/mcpConfigurationService.ts` ‚Üí `src/extension/services/MCPConfigurationService.ts`
3. `src/planModeToolsService.ts` ‚Üí `src/extension/services/PlanModeToolsService.ts`
4. `src/fileSnapshotService.ts` ‚Üí `src/extension/services/FileSnapshotService.ts`
5. `src/messageEnhancementService.ts` ‚Üí `src/extension/services/MessageEnhancementService.ts`

**Steps**:
- [ ] Create `src/extension/services/` directory
- [ ] Move existing 5 services to new directory (using `git mv` to preserve history)
- [ ] Update all import statements in:
  - [ ] `src/extension.ts`
  - [ ] `src/sdkSessionManager.ts`
  - [ ] `src/chatViewProvider.ts`
  - [ ] All test files
- [ ] Optional: Create barrel export `src/extension/services/index.ts`
- [ ] Build: `npm run compile` ‚Üí verify no errors
- [ ] Run all tests: `npm test` ‚Üí verify all pass
- [ ] Build and install: `./test-extension.sh`
- [ ] Manual testing checklist (see below)
- [ ] Verify logs show no errors
- [ ] Commit: "refactor: organize all services in src/extension/services/"

**Import pattern before**:
```typescript
import { ModelCapabilitiesService } from './modelCapabilitiesService';
import { MCPConfigurationService } from './mcpConfigurationService';
```

**Import pattern after**:
```typescript
import { ModelCapabilitiesService } from './extension/services/ModelCapabilitiesService';
import { MCPConfigurationService } from './extension/services/MCPConfigurationService';
```

**Or with barrel export**:
```typescript
import { 
  ModelCapabilitiesService,
  MCPConfigurationService,
  PlanModeToolsService,
  FileSnapshotService,
  MessageEnhancementService
} from './extension/services';
```

---

### Final Validation
- [ ] Run full test suite: `npm test`
- [ ] Build and install: `./test-extension.sh`
- [ ] Manual testing checklist (see below)
- [ ] Check logs in "Copilot CLI" output channel
- [ ] Performance check (no noticeable slowdown)
- [ ] Update CHANGELOG.md
- [ ] Update phase-3-extract-services.md to mark ‚úÖ COMPLETE

---

## Manual Testing Checklist

After each service extraction and final integration:

**Core Functionality**:
- [ ] Open chat panel (Ctrl+Shift+P ‚Üí "Copilot CLI: Open Chat")
- [ ] Send a message and get response
- [ ] View message history
- [ ] Session indicator shows green (active)

**Session Management**:
- [ ] New session (+ icon at top)
- [ ] Switch session (dropdown)
- [ ] Resume last session on reopen
- [ ] Session list shows correct labels
- [ ] Folder filtering works

**Plan Mode** (CRITICAL - After Phase 0):
- [ ] Toggle plan mode (Shift+Tab)
- [ ] AI can see all 11 tools
- [ ] AI receives correct system prompt
- [ ] View plan.md (Ctrl+Y)
- [ ] Accept plan
- [ ] Reject plan
- [ ] Switch back to work mode

**File Tracking**:
- [ ] Active file shows in panel
- [ ] File updates when switching editors
- [ ] Clears when all files closed

**Error Handling**:
- [ ] Stop session command works
- [ ] Abort message works
- [ ] Auth errors show helpful dialogs

**Configuration**:
- [ ] YOLO mode works
- [ ] Model selection works
- [ ] Tool allowlists work

---

## Success Metrics

**Code Reduction**:
- ‚úÖ extension.ts: 879 ‚Üí ~200 lines (77% reduction) üéØ
- ‚úÖ sdkSessionManager.ts: 1568 ‚Üí ~1450 lines (-118 lines, -7.5%) üéØ
- ‚úÖ chatViewProvider.ts: 539 ‚Üí ~300 lines (44% reduction) üéØ
- ‚úÖ All new services under 200 lines each

**Organization**:
- ‚úÖ All 10 services in `src/extension/services/` directory
- ‚úÖ Clean barrel export (optional)
- ‚úÖ Consistent naming: PascalCase service files

**Configuration Abstraction** (NEW!):
- ‚úÖ PlanModeToolsService owns ALL plan mode configuration
- ‚úÖ No hard-coded arrays in sdkSessionManager
- ‚úÖ No hard-coded prompts in sdkSessionManager
- ‚úÖ Future-ready for UI customization
- ‚úÖ System prompt engineering enabled

**Quality Metrics**:
- ‚úÖ 100% test coverage for all services
- ‚úÖ All existing tests still pass (no regressions)
- ‚úÖ Clean separation of concerns
- ‚úÖ Single responsibility per service
- ‚úÖ No circular dependencies

**Test Coverage** (Minimum):
- PlanModeToolsService Enhancement: 9+ tests
- ConfigurationService: 6+ tests
- SessionService: 12+ tests
- StartupService: 8+ tests
- CommandHandlerService: 12+ tests
- ActiveFileTrackerService: 7+ tests (optional)
- **Total: 54+ new tests minimum**

---

## Technical Considerations

### Dependency Injection
Services should accept dependencies in constructor:
```typescript
export class SessionService {
  constructor(
    private readonly logger: Logger,
    private readonly backendState: BackendState,
    private readonly configService: ConfigurationService
  ) {}
}
```

### Error Handling
- All services must handle errors gracefully
- Return meaningful error messages
- Log errors appropriately with Logger
- Don't crash the extension

### State Management
- Services should be stateless where possible
- Use BackendState for shared state
- Avoid service-to-service coupling
- Use events for loose coupling when needed

### Testing Strategy
- Use mocks for VS Code APIs (vscode.workspace, vscode.window, etc.)
- Use real BackendState (it's in-memory, easy to test)
- Mock file system for session history loading
- Integration tests for end-to-end flows

### Service Organization
- All services in `src/extension/services/` directory
- PascalCase file names (e.g., `SessionService.ts`)
- Export interfaces alongside implementations
- Optional barrel export `index.ts` for convenience

### Configuration Abstraction Pattern
- Services own their configuration (don't hard-code)
- Provide getter methods for configuration
- Enable future UI customization
- Separate configuration from orchestration

### Git Best Practices
- Use `git mv` when moving files (preserves history)
- Separate commits for moves vs. changes
- Clear commit messages following convention

---

## Validation Checklist (Per Original Phase 3 Plan)

### Service Quality
- [ ] Each service has single, clear responsibility
- [ ] Services are independently testable
- [ ] No circular dependencies between services
- [ ] Services use dependency injection
- [ ] Service interfaces are well-defined
- [ ] Configuration abstracted from orchestration ‚ú® NEW

### Functionality
- [ ] All existing features work unchanged
- [ ] Session management works
- [ ] Copilot SDK interaction works
- [ ] Plan mode works (CRITICAL - verify after Phase 0)
- [ ] File tracking works
- [ ] Configuration loading works

### Code Quality
- [ ] No duplicate logic across services
- [ ] Clear separation of concerns
- [ ] Easy to mock services for testing
- [ ] Extension.ts is under 200 lines ‚úÖ
- [ ] ChatViewProvider.ts is under 300 lines ‚úÖ
- [ ] All services organized in proper directory ‚úÖ
- [ ] No hard-coded configuration ‚ú® NEW

### Testing
- [ ] Unit tests for each service
- [ ] Integration tests for service interactions
- [ ] All existing tests still pass
- [ ] Can mock services in tests
- [ ] No test breakage from file moves

---

## Non-Goals (From Original Phase 3 Plan)

- ‚ùå Do NOT add new features
- ‚ùå Do NOT change message contracts (already done in Phase 2)
- ‚ùå Do NOT refactor webview UI (that's Phase 4)
- ‚ùå Do NOT implement MCP UI yet (that's Phase 6)
- ‚ùå Do NOT extract services speculatively (only extract what we need now)
- ‚ùå Do NOT create full PlanModeService (enhance existing PlanModeToolsService instead)

---

## Dependencies
- ‚úÖ Phase 2 (RPC layer) is complete
- ‚úÖ 5 services already extracted in v2.2+

---

## Risks & Mitigations

**Risk**: Circular dependencies between services
**Mitigation**: Design service boundaries carefully, use events for decoupling, inject dependencies via constructor

**Risk**: Over-abstraction makes code harder to follow
**Mitigation**: Keep services concrete, avoid deep inheritance, favor composition

**Risk**: Service initialization order matters
**Mitigation**: Use dependency injection, explicit initialization order in activate()

**Risk**: Breaking existing functionality during refactor
**Mitigation**: Extract one service at a time, test thoroughly after each, use TDD RED-GREEN-REFACTOR

**Risk**: Tests become brittle with too many mocks
**Mitigation**: Use real implementations where possible (Logger, BackendState), mock only VS Code APIs

**Risk**: File moves break imports and tests
**Mitigation**: Use `git mv`, update all imports systematically, run full test suite after moves, verify build succeeds

**Risk**: Breaking plan mode with configuration abstraction
**Mitigation**: Phase 0 is FIRST priority, test thoroughly before moving to other services, verify system prompt is identical

---

## Notes

- This is the "big cleanup" phase - we're finishing what was started in v2.2
- **Configuration abstraction is the key pattern** - separate config from orchestration
- Focus on single responsibility principle
- Services should be boring and predictable
- Don't over-engineer - simple classes are fine
- Goal is testability and clarity
- Use TDD religiously - write tests FIRST, always
- Final refactor organizes all 10 services in proper directory structure
- **Phase 0 (PlanModeToolsService enhancement) sets the pattern for future configuration abstraction**

---

## References

- Original Phase 3 plan: `planning/ in-progress/phase-3-extract-services.md`
- Completed services refactor: `planning/completed/SERVICES-REFACTOR.md`
- 3.0 architecture plan: `planning/ in-progress/3.0-CODE-REFACTOR.md`
- Test examples: `tests/file-snapshot-service.test.js`, `tests/mcp-configuration-service.test.js`
- TDD guidelines: COPILOT.md "Working with Planning Mode" and "Test-First Development"
- Configuration abstraction rationale: This plan, Phase 0 analysis

---

## Future Opportunities (Post-Phase 3)

The configuration abstraction pattern established in Phase 0 opens up future possibilities:

**System Prompt Engineering**:
- UI for editing plan mode prompts
- Workspace-specific prompt customization
- Prompt templates library
- A/B testing different prompts

**Tool Customization**:
- UI for selecting which tools are available in plan mode
- Project-specific tool restrictions
- Custom tool definitions
- Tool presets (e.g., "research mode", "design mode")

**Configuration Management**:
- Workspace-level service configuration
- User-level defaults
- Configuration import/export
- Configuration profiles

This is the power of configuration abstraction! üöÄ
